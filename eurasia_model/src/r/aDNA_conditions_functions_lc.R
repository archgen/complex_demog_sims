#
#       eigenstrat_aDNA_conditions_processing.R
#       This script provides a series of functions that take Eigenstrat files,  
#       generated by msPrime (https://github.com/tskit-dev/msprime) and concatenated    
#       into single a single Eigenstrat file for each simulation, and reprocess them with  
#       artifacts that reflect ancient DNA conditions. It takes as input the simulated Eigenstrat
#       files and Eigenstrat files generated from real ancient DNA sequencing from which data missingness 
#       will be positioned on the simulated Eigenstrat files. The real aDNA Eigenstrat files are the 1.2M positions 
#       generated by the Reich lab https://reich.hms.harvard.edu/. The simulated Eigenstrat files will also be ascertained 
#       on the individual samples indicated in the sample sheet.
#
#       Created by Matthew Williams & Christian Huber, DATE: 



################################################
# FUNCTION definitions                         #
################################################
# Function for loading eigenstrat files:
read_eigenstrat = function(eig_geno, eig_snp, eig_ind) {
  fn_geno = eig_geno
  fn_snp = eig_snp
  fn_ind = eig_ind
  sampleSize = nchar(readLines(fn_geno, n=1))
  geno = vroom_fwf(file = fn_geno,
                   col_positions = fwf_widths(rep(1, sampleSize), col_names = NULL),
                   col_types = paste(rep("i", sampleSize), collapse=""))
  setDT(geno)
  snp = fread(fn_snp, header = FALSE)
  colnames(snp) = c("snpID", "chr", "gen_pos", "pos", "refAllele", "altAllele")
  ind = fread(fn_ind, header = FALSE)
  colnames(ind) = c("ind", "sex", "group")
  return(list(geno = geno, snp = snp, ind = ind))
}

# return eigenstrat dataset with no tri-allelic sites
triAllelFilterd = function(eigenstrat_file) {
  geno = eigenstrat_file[["geno"]]
  snp = eigenstrat_file[["snp"]]
  ind = eigenstrat_file[["ind"]]
  geno[, rN:=seq(1:(nrow(geno)))]
  sel.col = copy(colnames(geno[,1:(ncol(geno)-1)]))
  rN.col = "rN"
  biSNPrN = geno[geno[, Reduce(`&`, lapply(.SD, `!=`, 3)),.SDcols = sel.col], ..rN.col]
  bi_snp = snp[biSNPrN$rN, ]
  bi_geno = geno[biSNPrN$rN, .SD, .SDcols = sel.col]
  cat("Simulated ", nrow(snp), " postiions of which ", (nrow(snp) - nrow(bi_snp)), " are tr-allelic sites.\n 
      As such, filtered bi-allelic  dataset contains ", nrow(bi_snp), " positions \n")
  return(list(geno = bi_geno, snp = bi_snp, ind = ind))
}

# Adding ascertainment bias to sims
# Note that this is assuming that sims generate chromosomes, and that 0 is ancestral, and 2 is derived in this chromosome (i.e. no diploids and thus no hets).
# Also, no missing data.
add_ascertainment_bias = function(eigenstrat_file, ascertainment_based_on = list(c(1,2))) {
  geno = eigenstrat_file[["geno"]]
  snp = eigenstrat_file[["snp"]]
  ind = eigenstrat_file[["ind"]]
  hetID = data.table()
  #print(ascertainment_based_on)
  if(length(ascertainment_based_on) != 0){
    for (i in 1:length(ascertainment_based_on)) {
      ID = ascertainment_based_on[[i]]
      ascertainmentChromosomes = geno[, ..ID]
      hetID = cbind(hetID, ascertainmentChromosomes[, .SD[,1] != .SD[,2]][,1]) # are the two diploid sites hetero in the ascertain inds [T/F]. 
    }
    hetID_allInds = rowSums(hetID) > 0  # If at least one is heterozygous, then keep the row
    return(list(geno = geno[hetID_allInds,], snp = snp[hetID_allInds,], ind = ind))
  }else{
    return(list(geno = geno, snp = snp, ind = ind))
  }
}


# Convert haploid msprime sims (each sample is a single chromosome of a simulated diploid individual) into diploid individuals 0=homoALT, 1=het, 2=homREF
makeSimDiploid = function(eigenstrat_file) {
  geno = eigenstrat_file[["geno"]]
  snp = eigenstrat_file[["snp"]]
  ind = eigenstrat_file[["ind"]]
  firstChr_ID = seq(1, ncol(geno), 2)
  secondChr_ID = seq(2, ncol(geno), 2)
  genoDiploid = geno[, ..firstChr_ID]/2 + geno[, ..secondChr_ID]/2
  return(list(geno = genoDiploid, snp = snp, ind = ind[firstChr_ID,]))
}

# Pseudohaplodize diploid data by randomly selecting one allele at heterozygote sites
pseudoHaplodize = function(eigenstrat_file, who_gets_pseudoHap) {
  geno = eigenstrat_file[["geno"]]
  snp = eigenstrat_file[["snp"]]
  ind = eigenstrat_file[["ind"]]
  setDT(geno)
  numHets = sum(geno[,..who_gets_pseudoHap] == 1)
  pseudoHap_geno <- geno[,..who_gets_pseudoHap]
  pseudoHap_geno[pseudoHap_geno == 1] <- sample(x = c(0,2), size = numHets, replace = TRUE)
  setDF(geno)
  geno[who_gets_pseudoHap] <- pseudoHap_geno
  setDT(geno)
  return(list(geno = geno, snp = snp, ind = ind))
}

# Adding missing data based on reference data
# Assumes that 9 is coding for missing data
v50_0_1240Kdownsamp_add_missing = function(eigenstrat_file, reference_file, who_gets_missing) {
  geno = eigenstrat_file[["geno"]]
  snp = eigenstrat_file[["snp"]]
  ind = eigenstrat_file[["ind"]]
  refgenoMissing = reference_file[["geno"]] == 9
  numSNPs_ref = nrow(reference_file[["geno"]])
  
  if (nrow(refgenoMissing) > nrow(geno)){
    cat("Only", nrow(geno), " polymorphic SNPs in the simulated eigenstrat_file, which is less than the number of missing data positions in the reference dataset",
        nrow(refgenoMissing),", SNPs.\n As such, missingness will be sampled from the reference panel with replacement\n")
    sampleSNPs = sample(1:nrow(geno), size = numSNPs_ref, replace = TRUE)   # Randomly select rows with replacement as there are not enough SNPs to sample without-repacement
    sampleSNPs = sampleSNPs[order(sampleSNPs)]   # Sort positions
    geno = geno[sampleSNPs, ]
    snp = snp[sampleSNPs, ]
  } else {
    # Downsample eigenstrat_file to same number of SNPs as reference_file
    sampleSNPs = sample(1:nrow(geno), size = numSNPs_ref, replace = FALSE) # Randomly select rows without replacement
    sampleSNPs = sampleSNPs[order(sampleSNPs)]   # Sort positions
    geno = geno[sampleSNPs, ]
    snp = snp[sampleSNPs, ]
  }
  # Add missing values to eigenstrat_file (sims), resample columns of reference file to have same number of columns as eigenstrat_file
  # If possible, resample reference_file columns without replacement
  if (length(who_gets_missing) <= ncol(refgenoMissing)) {
    sampleColumns = sort(sample(x = 1:ncol(refgenoMissing), size = length(who_gets_missing), replace = FALSE))
  } else {
    sampleColumns = sort(sample(x = 1:ncol(refgenoMissing), size = length(who_gets_missing), replace = TRUE))
  }
  refgenoMissing_resampled = matrix(FALSE, nrow = nrow(geno), ncol = ncol(geno)) # Matrix with all FALSE instances of the size of the 1.2M subsetted .geno sim Eigenstrat
  refgenoMissing_resampled[, who_gets_missing] = refgenoMissing[, sampleColumns]  # some individuals get missing data
  geno[refgenoMissing_resampled] = 9
  return(list(geno = geno, snp = snp, ind = ind))
}

#recode_snpFile = function(eigenstrat_file, hapmap_file) {
#  geno = eigenstrat_file[["geno"]]
#  snp = eigenstrat_file[["snp"]]
#  ind = eigenstrat_file[["ind"]]
#  hapmap = hapmap_file
#  hapDF = data.frame(x=hapmap$`Position(bp)`, y=hapmap$`Map(cM)`) #cum_map_MSP
#  interGenPos = data.frame(approx(hapDF$x, hapDF$y, xout=snp$pos))
#  snp$gen_pos = interGenPos$y
#  return(list(geno = geno, snp = snp, ind = ind))
#}

recode_snpFile = function(eigenstrat_file) {
  geno = eigenstrat_file[["geno"]]
  snp = eigenstrat_file[["snp"]]
  ind = eigenstrat_file[["ind"]]
  
  #Chromosome Lengths
  chr1_L = 248956422
  chr2_L = 242193529
  chr3_L = 198295559
  chr4_L = 190214555
  chr5_L = 181538259
  chr6_L = 170805979
  chr7_L = 159345973
  chr8_L = 145138636
  chr9_L = 138394717
  chr10_L = 133797422
  chr11_L = 135086622
  chr12_L = 133275309
  chr13_L = 114364328
  chr14_L = 107043718
  chr15_L = 101991189
  chr16_L = 90338345
  chr17_L = 83257441
  chr18_L = 80373285
  chr19_L = 58617616
  chr20_L = 64444167
  chr21_L = 46709983
  chr22_L = 50818468
  
  # Define the chromosome lengths in a list
  chromosome_lengths <- c(
    chr1_L, chr2_L, chr3_L, chr4_L, chr5_L,
    chr6_L, chr7_L, chr8_L, chr9_L, chr10_L,
    chr11_L, chr12_L, chr13_L, chr14_L, chr15_L,
    chr16_L, chr17_L, chr18_L, chr19_L, chr20_L,
    chr21_L, chr22_L
  )
  
  snp[, V2 := findInterval(V4, c(0,chr_max))]
  
  #' Recode the phyical position as the current pos - the cumulitative max pos of the preceeding chr
  snp[V2 %between% c(2, 22), new_pos := V4 - chr_max[V2 - 1], by = V2]
  snp[V2 == 1,new_pos := V4]
  snp <- snp[,.(V1, V2, V3, new_pos, V5, V6)]
  
  return(list(geno = geno, snp = snp, ind = ind))
}


# Write out the data into pseudohaploid eigenstrat file format.
write_eigenstrat_pshap = function(eigenstrat_file, fn) {
  outfile = file.path(fn)
  #write.table(eigenstrat_file$geno, sep="", quote = FALSE, row.names = FALSE, col.names = FALSE, file = paste0(outfile, ".geno"))
  fwrite(eigenstrat_file$geno, sep='', quote = FALSE, row.names = FALSE, col.names = FALSE, file = paste0(outfile, ".geno"))
  fwrite(eigenstrat_file$snp, sep="\t", quote = FALSE, row.names = FALSE, col.names = FALSE, file = paste0(outfile, ".snp"))
  fwrite(eigenstrat_file$ind, sep="\t", quote = FALSE, row.names = FALSE, col.names = FALSE, file = paste0(outfile, ".ind"))
}

